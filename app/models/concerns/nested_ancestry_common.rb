module NestedAncestryCommon
  extend ActiveSupport::Concern

  included do
    audited :except => [:title], :allow_mass_assignment => true
    has_associated_audits
    has_ancestry :orphan_strategy => :restrict

    before_validation :set_title
    after_save :set_other_titles, :on => [:update, :destroy]
    after_save :update_matchers , :on => :update, :if => Proc.new {|obj| obj.title_changed?}

    validates :name, :presence => true, :uniqueness => {:scope => :ancestry, :case_sensitive => false }
    validates :title, :presence => true, :uniqueness => true

    scoped_search :on => :title, :complete_value => true, :default_order => true
    scoped_search :on => :name, :complete_value => :true

    # attribute used by *_names and *_name methods.  default is :name
    attr_name :title
  end

  # override title getter
  def title
    read_attribute(:title) || get_title
  end
  alias_method :to_label, :title

  def get_title
    return name if ancestry.empty?
    ancestors.map { |a| a.name + '/' }.join + name
  end
  alias_method :get_label, :get_title

  def to_param
    "#{id}-#{get_title.parameterize}"
  end

  module ClassMethods
    def nested_attribute_for *opts

      opts.each do |field|

        # Example method
        # def inherited_compute_profile_id
        #   read_attribute(:compute_profile_id) || nested_compute_profile_id
        # end
        define_method "inherited_#{field}" do
          read_attribute(field) || nested(field)
        end

        # Example method - only override method generated by assocation if there is ancestry.
        # if ancestry.present?
        #   def compute_profile
        #    ComputeProfile.find_by_id(inherited_compute_profile_id)
        #  end
        # end
        if md = field.to_s.match(/(\w+)_id$/)
          define_method md[1] do
            if ancestry.present?
              klass = md[1]
              klass = "smart_proxy" if ["puppet_proxy", "puppet_ca_proxy"].include?(md[1])
              klass.classify.constantize.find_by_id(send("inherited_#{field}"))
            else
              # () is required. Otherwise, get RuntimeError: implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly.
              super()
            end
          end
        end

      end
    end
  end

  def nested attr
    self.class.sort_by_ancestry(ancestors.where("#{attr} is not NULL")).last.try(attr) if ancestry.present?
  end

  private

  def set_title
    self.title = get_title if (name_changed? || ancestry_changed? || title.blank?)
  end

  def set_other_titles
    if name_changed? || ancestry_changed?
      self.class.where('ancestry IS NOT NULL').each do |obj|
        if obj.path_ids.include?(self.id)
          obj.update_attributes(:title => obj.get_title)
        end
      end
    end
  end

  def obj_type
    self.class.to_s.downcase
  end

  def update_matchers
    lookup_values = LookupValue.where(:match => "#{obj_type}=#{title_was}")
    lookup_values.update_all(:match => "#{obj_type}=#{title}")
  end

end
