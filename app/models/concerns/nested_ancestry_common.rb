module NestedAncestryCommon
  extend ActiveSupport::Concern

  included do
    audited :except => [:label], :allow_mass_assignment => true
    has_associated_audits
    has_ancestry :orphan_strategy => :restrict

    before_validation :set_label
    after_save :set_other_labels, :on => [:update, :destroy]
    after_save :update_matchers , :on => :update, :if => Proc.new {|obj| obj.label_changed?}

    validates :name, :presence => true, :uniqueness => {:scope => :ancestry, :case_sensitive => false }
    validates :label, :presence => true, :uniqueness => true

    scoped_search :on => :label, :complete_value => :true, :default_order => true

    # attribute used by *_names and *_name methods.  default is :name
    attr_name :label
  end

  def to_label
    return label if label
    get_label
  end

  def get_label
    return name if ancestry.empty?
    ancestors.map { |a| a.name + '/' }.join + name
  end

  module ClassMethods
    def nested_attribute_for *opts

      opts.each do |field|

        # Example method
        # def inherited_compute_profile_id
        #   read_attribute(:compute_profile_id) || nested_compute_profile_id
        # end
        define_method "inherited_#{field}" do
          read_attribute(field) || nested(field)
        end

        # Example method - only override method generated by assocation if there is ancestry.
        # if ancestry.present?
        #   def compute_profile
        #    ComputeProfile.find_by_id(inherited_compute_profile_id)
        #  end
        # end
        if md = field.to_s.match(/(\w+)_id$/)
          define_method md[1] do
            if ancestry.present?
              klass = md[1]
              klass = "smart_proxy" if ["puppet_proxy", "puppet_ca_proxy"].include?(md[1])
              klass.classify.constantize.find_by_id(send("inherited_#{field}"))
            else
              # () is required. Otherwise, get RuntimeError: implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly.
              super()
            end
          end
        end

      end
    end
  end

  def nested attr
    self.class.sort_by_ancestry(ancestors.where("#{attr} is not NULL")).last.try(attr) if ancestry.present?
  end

  private

  def set_label
    self.label = get_label if (name_changed? || ancestry_changed? || label.blank?)
  end

  def set_other_labels
    if name_changed? || ancestry_changed?
      self.class.where('ancestry IS NOT NULL').each do |obj|
        if obj.path_ids.include?(self.id)
          obj.update_attributes(:label => obj.get_label)
        end
      end
    end
  end

  def obj_type
    self.class.to_s.downcase
  end

  def update_matchers
    lookup_values = LookupValue.where(:match => "#{obj_type}=#{label_was}")
    lookup_values.update_all(:match => "#{obj_type}=#{label}")
  end

end
