require 'test_helper'

class NestedAncestryDummy < ActiveRecord::Base
  include NestedAncestryCommon
  self.table_name = 'hostgroups'

  # Sample relations to test methods autogenerated by nested_attribute_for
  belongs_to :subnet
  nested_attribute_for :medium_id, :subnet_id
end

class NestedAncestryCommonTest < ActiveSupport::TestCase
  setup do
    User.current = users :admin
  end

  context 'name validations' do
    test 'name must not be empty' do
      dummy = NestedAncestryDummy.new
      refute dummy.save
    end

    test 'name must not be blank' do
      dummy = NestedAncestryDummy.new(:name => "      ")
      refute dummy.save
    end

    test "name must be unique" do
      dummy = NestedAncestryDummy.new(:name => 'foo')
      assert dummy.save

      other_dummy = NestedAncestryDummy.new(:name => 'foo')
      refute other_dummy.save
    end

    test 'name must be unique within ancestry scope' do
      NestedAncestryDummy.create(:name => 'foo')
      second_dummy = NestedAncestryDummy.new(:name => 'foo')
      refute second_dummy.save
    end

    test 'name can be the same if parent is different' do
      parent1 = NestedAncestryDummy.create(:name => 'foo')
      parent2 = NestedAncestryDummy.create(:name => 'bar')

      assert_difference('NestedAncestryDummy.count', 2) do
        child1 = NestedAncestryDummy.create(:name => 'Building A', :parent => parent1)
        child2 = NestedAncestryDummy.create(:name => 'Building A', :parent => parent2)
        assert_equal 'foo/Building A', child1.title
        assert_equal 'bar/Building A', child2.title
      end
    end

    test 'to_s returns name' do
      dummy = NestedAncestryDummy.new(:name => 'dummy name')
      assert_equal 'dummy name', dummy.to_s
    end

    test "name can't be too big to create lookup value matcher over 255 characters" do
      parent = NestedAncestryDummy.create(:name => 'dummyparent')
      min_lookupvalue_length = "#{parent.send(:obj_type)}=#{parent.title}".length + 1
      dummy = NestedAncestryDummy.new(:parent => parent, :name => 'a' * 256)
      refute_valid dummy
      assert_equal 'is too long (maximum is %s characters)' % (255 -  min_lookupvalue_length),
                   dummy.errors[:name].first
    end

    test 'name can be up to 255 characters' do
      parent = NestedAncestryDummy.create(:name => 'dummyparent')
      min_lookupvalue_length = "#{parent.send(:obj_type)}=#{parent.title}".length + 1
      dummy = NestedAncestryDummy.new(:parent => parent,
                                      :name => 'a' * (255 - min_lookupvalue_length))
      assert_valid dummy
    end

    test 'name should not validate when matcher is exactly 256 characters' do
      parent = NestedAncestryDummy.create(:name => 'a' * (255 - "nestedancestrydummy=".length - 1))
      dummy  = NestedAncestryDummy.new(:parent => parent, :name => 'b')
      refute_valid dummy
      assert_equal _('is too long (maximum is 0 characters)'), dummy.errors[:name].first
    end
  end

  test 'inherited dummy should have correct path' do
    parent = NestedAncestryDummy.create(:name => 'dummyparent')
    dummy  = NestedAncestryDummy.create(:name => 'rack1', :parent_id => parent.id)
    assert_equal 'dummyparent/rack1', dummy.title
  end

  test 'ancestry orphan strategy is restrict' do
    assert_equal NestedAncestryDummy.orphan_strategy, :restrict
  end

  test 'changing name of dummy updates other dummy titles' do
    parent_dummy = NestedAncestryDummy.create(:name => 'foo')
    dummy        = NestedAncestryDummy.create(:name => 'bar')
    assert dummy.update_attribute(:parent_id, parent_dummy.id)
    assert parent_dummy.update_attribute(:name, 'new_common')
    dummy.reload
    assert_equal 'new_common/bar', dummy.title
  end

  test 'deleting a dummy with children does not change labels' do
    parent_dummy = NestedAncestryDummy.create(:name => 'foo')
    dummy        = NestedAncestryDummy.create(:name => 'bar')
    assert dummy.update_attribute(:parent_id, parent_dummy.id)

    #attempt to destroy parent dummy
    refute parent_dummy.destroy rescue Ancestry::AncestryException
    dummy.reload
    assert_equal 'foo/bar', dummy.title
  end

  context 'inherited attributes' do
    setup do
      @dummy = NestedAncestryDummy.create(:name => 'foo')
    end

    test 'generates inherited_attribute methods' do
      [:medium_id, :subnet_id].each do |field|
        assert @dummy.respond_to?("inherited_#{field}")
      end
    end

    test 'inherited value equals field value if no ancestry' do
      [:medium_id, :subnet_id].each do |field|
        assert_equal @dummy.send(field), @dummy.send("inherited_#{field}")
      end
    end

    context 'with parent' do
      setup do
        @parent = NestedAncestryDummy.create(:name => 'bar')
        @dummy.update_attribute(:parent_id, @parent.id)
      end

      test "inherited value equals parent's value if the child's value is null" do
        @parent.update_attribute(:subnet_id, 1)
        assert_equal @parent.subnet_id, @dummy.inherited_subnet_id
      end

      test "inherited value does not inherit parent's value if the child's value is not null" do
        @parent.update_attribute(:subnet_id, 1)
        @dummy.update_attribute(:subnet_id, 2)
        refute_equal @parent.subnet_id, @dummy.inherited_subnet_id
        assert_equal @dummy.subnet_id,  @dummy.inherited_subnet_id
      end

      test "inherited object equals parent object if the child's value is null" do
        @parent.update_attribute(:subnet, subnets(:one))
        assert_equal @parent.subnet, @dummy.subnet
      end

      test "inherited object does not inherit parent object if the child's value is not null" do
        @parent.update_attribute(:subnet, subnets(:one))
        @dummy.update_attribute(:subnet, subnets(:two))
        refute_equal @parent.subnet, @dummy.subnet
        assert_equal subnets(:two), @dummy.subnet
      end
    end
  end
end
